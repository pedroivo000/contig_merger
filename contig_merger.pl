#!/usr/bin/perl

#contig_merger.pl
#Code by Pedro Ivo Guimarï¿½es, 2016

#Script to merge contigs inside the clusters present in the cluster files generated by
#BBTools Dedupe.sh program using the .dot file and the fasta sequences in clusters.

use warnings;
use strict;
use FastaTools;
use List::Util;
use List::MoreUtils qw(first_index);
use Array::Utils qw(array_minus);
use File::Basename;
use Getopt::Std;
use Data::Dumper;
use Graph;
use Graph::Traversal::DFS;
use Graph::Reader::Dot;

########################################
#### Declaring command-line options ####
########################################
our($opt_i, $opt_c, $opt_h, $opt_v, $opt_o);
getopts('i:c:hvo:');

#Declaring the options:
my $graph_dot_file = $opt_i;
my $cluster_files = $opt_c;
my $output_file = $opt_o || "merged_contigs.fasta";

#################################
#### Importing cluster files ####
#################################
print "Importing cluster files...";
my ($filename_pattern, $path) = fileparse($cluster_files);
$cluster_files =~ tr/%/\*/; #changing the % character for the *, allowing pattern search

#Creating file with all the clusters' contig sequences:
my $allcontigs_file = $path."allcontigs.fastq";
system("cat $cluster_files > $allcontigs_file");

#Opening file with all contigs:
my %records = FastaTools::loadfastq($allcontigs_file);
print "Done!\n";

#####################################################
#### Importing and modifying the .dot graph file ####
#####################################################

# We will use the CPAN Graph::Reader module to manipulate the .dot file:
print "Opening graph file: $graph_dot_file...";
my $dot_reader = Graph::Reader::Dot->new();
my $dot_graph = $dot_reader->read_graph($graph_dot_file);

print "Done!\n";
#The first thing we have to do is to reorient the edges in the graph in order to
#make all edges correspond to a contig w/ overlap in the END -> contig w/ overlap in
#the BEGNNING> If we reorient the edges like this, we can use the directional graph
#information to construct the super-contigs in a greedy way, by merging the individual
#contigs in a specific 'path' in the cluster from the directed graph.

#We need all the edges in the graph:

print "Flipping the edges in the graph\n";
my @edges = $dot_graph->edges;

#Iterating through each edge:
foreach my $edge (@edges) {
	#In order to check if the edges are in the right orientation, we need to get the
	#label information for each one of them:
	my $label = $dot_graph->get_edge_attribute($edge->[0], $edge->[1], 'label');
	my @label = split(/,/,$label);
	#Each element from @label has a meaning:
	my $overlap_info = {
		overlap_type 		=> $label[0],
		overlap_length		=> $label[1],
		mismatches			=> $label[2],
		edits				=> $label[3],
		from_ctg_length		=> $label[4],
		ov_startcoord_from 	=> $label[5],
		ov_endcoord_from	=> $label[6],
		to_ctg_length		=> $label[7],
		ov_startcoord_to	=> $label[8],
		ov_endcoord_to		=> $label[9]
	};

	#We also need the node names:
	my $from_node = $edge->[0];
	my $to_node   = $edge->[1];

	#We can use the overlap beggining and ending coordinates to check if edge is in the
	#correct orientation (END -> BEG):
	if ($overlap_info->{'ov_startcoord_from'} == 0) {
		#Deleting the wrong direction edge:
		$dot_graph->delete_edge($from_node, $to_node);

		#Adding the reversed edge
		$dot_graph->add_edge($to_node, $from_node);

		#We also have to change the order of the label data:
		my $new_overlap_info = $overlap_info;
		$new_overlap_info->{'from_ctg_length'} 		= $label[7];
		$new_overlap_info->{'ov_startcoord_from'}	= $label[8];
		$new_overlap_info->{'ov_endcoord_from'} 	= $label[9];
		$new_overlap_info->{'to_ctg_length'}		= $label[4];
		$new_overlap_info->{'ov_startcoord_to'}  	= $label[5];
		$new_overlap_info->{'ov_endcoord_to'} 		= $label[6];

		#Replacing the old label with the new one:
		$dot_graph->set_edge_attribute($to_node, $from_node, 'label', $new_overlap_info);
	} else {
		$dot_graph->set_edge_attribute($from_node, $to_node, 'label', $overlap_info);
	}
}
print "Done\n";

######################################################
#### Identifying the overlapping contigs in graph ####
######################################################

#The graph file contains the overlap map for the different contig clusters. In order to
#merge the clusters into super-contigs, we have to extract all the paths corresponding
#to the longest overlap between the contigs in a cluster. In order to do this, we need to
#compute the graph traversal.

die "Graph contains cycle!" if $dot_graph->has_a_cycle; #otherwise program will be stuck
my $paths = build_paths($dot_graph);

#Some of the paths have branches, and that causes sequence duplication during
#contig extension. We need to check which one of the paths have branches:
my %path_branches;
foreach my $path (@$paths) {
    my @branches;
    # my $number_of_ctgs_in_path = @$path;
    foreach my $other_path (@$paths) {
      # my $number_of_ctgs_in_other_path = @$other_path;
      # next if ($other_path == $path);

      my @diff = array_minus(@$other_path, @$path);
      if (@diff==0){
          push(@branches, $other_path);
      }
    }
    $path_branches{$path} = \@branches;
}

print Dumper(\%path_branches);

#Now that we have the paths, we can use the overlap information to extend the contigs in
#a path/cluster:
my %extended_contigs; #will hold the extend contig sequence and information
my $count = 0;

#Creating merging statistics output file:
my $merging_stats_file = "merged_contigs.info";
open (my $info_out, ">$merging_stats_file") || die "Can't open $merging_stats_file. $!\n";

#Adding header to information file w/ run informations:
my @file_stats = stat($info_out);
my $last_modify_time = scalar localtime $file_stats[9];
my $header =
"Merged contigs information file
File: $merging_stats_file;
Creating time: $last_modify_time;
Input files:
 - All contigs FASTq file: $allcontigs_file;
 - Graph file: $graph_dot_file\n";

print $info_out "$header";

my %duplication_counter;
foreach my $overlap_path (@$paths) {
	$count++;
	my $name = "merged_contig_$count";
	my $extended_contig_seq = ''; #will hold the merged contig sequence
	my @contig_names = @$overlap_path;	#list of contigs present in current path
	my @sequences; #will hold all the sequences from the contigs with the
				   #overlapping regions deleted from the 'to' contig

	#Start printing to info output file:
	print $info_out "\nCLUSTER: $name\nparent_contigs\ttotal_length\tleft_ovlp_rmvd_length\n";

	#Loop through each contig in each path:
	foreach my $i (0..$#contig_names) {
		$duplication_counter{$contig_names[$i]}++;
		my $seq = $records{$contig_names[$i]}{'seq'};
		my $seq_length = length($seq);

		print $info_out "$contig_names[$i]\t$seq_length\t";
		#Removing the overlap region from all 'to' contigs:
		if ($dot_graph->has_edge($contig_names[$i-1], $contig_names[$i])) {
			my $overlap_info = $dot_graph->get_edge_attribute($contig_names[$i-1], $contig_names[$i], 'label');
			my $overlap_length = $overlap_info->{'overlap_length'};
			$seq = substr($seq, $overlap_length);
			push(@sequences, $seq);

			my $no_overlap_length = length($seq);
			print $info_out "$no_overlap_length\n";
		} else {
			#Getting the contig sequence from %records:
			push(@sequences, $seq);
			print $info_out "NA\n";
		}
	}
	#Now we can concatenate each sequence string
	$extended_contig_seq = join('', @sequences);
	my $merged_contig_length = length($extended_contig_seq);

	$extended_contigs{$name}{merged_contigs} = \@contig_names;
	$extended_contigs{$name}{seq} 			 =  $extended_contig_seq;
	print $info_out "merged_contig_length: $merged_contig_length\n";
}

<<<<<<< HEAD
$contig_duplitcation_counter = sort {$contig_duplication_counter{$b} <=> $contig_duplication_counter{$a}} %contig_duplication_counter
print "Parent contigs count:\n"; 
print Dumper \%contig_duplication_counter;
=======
# print "Parent contigs count:\n";
# foreach my $dup_ctg (sort {$duplication_counter{$b} <=> $duplication_counter{$a}} keys %duplication_counter) {
#   my $ctg_length = length($records{$dup_ctg}{'seq'});
#   my $dup_length = $ctg_length*$duplication_counter{$dup_ctg};
#
#   print "$dup_ctg\t$duplication_counter{$dup_ctg}\t$ctg_length\t$dup_length\n";
# }
>>>>>>> 8c91a61b0a271b46ce52d1881545b7a86f7ea1e7

#Print merged contig sequences to output file:
open(my $contigs_out, ">$output_file") || die "Can't open $output_file $!\n";
foreach my $contig_name (sort {substr($a, 14) <=> substr($b, 14)} keys %extended_contigs) {
	my $seq = $extended_contigs{$contig_name}{'seq'};
	print $contigs_out ">$contig_name\n$seq\n";
}

#####################
#### Subroutines ####
#####################

#Subroutine to find all paths starting from source nodes in the graph:
#(Written by ikegami, http://stackoverflow.com/a/41646812/2975263)
sub build_paths {
   my ($graph) = @_;

   my @paths;

   local *_helper = sub {
      my $v = $_[-1];
      my @successors = $graph->successors($v);
      if (@successors) {
         _helper(@_, $_)
            for @successors;
      } else {
         push @paths, [ @_ ];
      }
   };

   _helper($_)
      for $graph->source_vertices();

   return \@paths;
}
